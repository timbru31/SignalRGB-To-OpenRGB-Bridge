/// <reference types="node" />
/// <reference types="node" />
import EventEmitter from "events";
import Device from "./device";
import type { RGBColor } from "./device";
interface ModeInput {
    id?: number;
    name?: string;
    value?: number;
    flags?: number;
    speedMin?: number;
    speedMax?: number;
    brightnessMin?: number;
    brightnessMax?: number;
    colorMin?: number;
    colorMax?: number;
    speed?: number;
    brightness?: number;
    direction?: number;
    colorMode?: number;
    colors?: RGBColor[];
    flagList?: string[];
}
interface Settings {
    forceProtocolVersion?: number;
}
interface ResolveObject {
    resolve: (val: Buffer) => void;
    commandId: number;
    deviceId: number;
    header?: Buffer;
}
export default class Client extends EventEmitter {
    name: string;
    port: number;
    host: string;
    isConnected: boolean;
    protocolVersion: number | undefined;
    settings: Settings;
    protected resolver: ResolveObject[];
    protected currentPacketLength: number;
    private socket?;
    /**
     * @param {string} [name="nodejs"] name for the client
     * @param {number} [port=6742] port of the connection
     * @param {string} [host="127.0.0.1"] host of the connection
     * @param {Settings} [settings] settings for the connection
     */
    constructor(name: string, port: number, host: string, settings?: Settings);
    /**
     * connect to the OpenRGB-SDK-server
     */
    connect(timeout?: number): Promise<void>;
    /**
     * disconnect from the OpenRGB-SDK-server
     */
    disconnect(): void;
    /**
     * get the amount of devices
     * @returns {Promise<number>}
     */
    getControllerCount(): Promise<number>;
    /**
     * get the protocol version
     * @returns {Promise<number>}
     */
    getProtocolVersion(): Promise<number>;
    /**
     * get the properties of a device
     * @param {number} deviceId the id of the requested device
     * @returns {Promise<Device>}
     */
    getControllerData(deviceId: number): Promise<Device>;
    /**
     * get the properties of all devices
     * @returns {Promise<Device[]>}
     */
    getAllControllerData(): Promise<Device[]>;
    /**
     * get a list of all profiles
     * @returns {Promise<String[]>}
     */
    getProfileList(): Promise<string[]>;
    /**
     * request a rescan of devices in OpenRGB
     */
    requestRescan(): void;
    /**
     * set the name of the client
     * @param {string} name the name displayed in openrgb
     */
    setClientName(name: string): void;
    /**
     * update all leds of a device
     * @param {number} deviceId the id of the device
     * @param {RGBColor[]} colors the colors the device should be set to
     */
    updateLeds(deviceId: number, colors: RGBColor[]): void;
    /**
     * update all leds of a zone
     * @param {number} deviceId the id of the device
     * @param {number} zoneId the id of the zone
     * @param {RGBColor[]} colors the colors the zone should be set to
     */
    updateZoneLeds(deviceId: number, zoneId: number, colors: RGBColor[]): void;
    /**
     * update one led of a device
     * @param {number} deviceId the id of the device
     * @param {number} ledId the id of the led
     * @param {RGBColor} color the color the led should be set to
     */
    updateSingleLed(deviceId: number, ledId: number, color: RGBColor): void;
    /**
     * sets the device to its mode for individual led control
     * @param {number} deviceId the id of the requested device
     */
    setCustomMode(deviceId: number): void;
    /**
     * update the mode of a device
     * @param {number} deviceId the id of the device
     * @param {ModeInput} mode All fields are optional and missing ones will be filled in with the currently active settings.
     * Either id or name must be given as an indication for which mode should be set.
     * Purely informational fields like brightnessMax will be ignored but are allowed
     */
    updateMode(deviceId: number, mode: ModeInput | number | string): Promise<void>;
    /**
     * update the mode of a device and save it to the device
     * @param {number} deviceId the id of the device
     * @param {ModeInput} mode all fields are optional and missing ones will be filled in with the currently active settings
     * Either id or name must be given as an indication for which mode should be set.
     * Purely informational fields like brightnessMax will be ignored but are allowed
     */
    saveMode(deviceId: number, mode: ModeInput | number | string): Promise<void>;
    /**
     * resize a zone
     * @param {number} deviceId the id of the device
     * @param {number} zoneId the id of the zone
     * @param {number} zoneLength the length the zone should be set to
     */
    resizeZone(deviceId: number, zoneId: number, zoneLength: number): void;
    /**
     * create a new profile with the current state of the devices in openrgb
     * @param {string} name the name of the new profile
     */
    saveProfile(name: string): void;
    /**
     * load a profile out of the storage
     * @param {string} name the name of the profile that should be loaded
     */
    loadProfile(name: string): void;
    /**
     * delete a profile out of the storage
     * @param {string} name the name of the profile that should be deleted
     */
    deleteProfile(name: string): void;
    /**
     * adds a segment to the specified Zone
     * @param deviceId id of the device
     * @param zoneId id of the zone
     * @param name name of the new segment
     * @param type zone type of the zone
     * @param start first led in the segment
     * @param length amount of leds in the segment
    */
    addSegment(deviceId: number, zoneId: number, name: string, type: number, start: number, length: number): void;
    /**
     * removes a segment
     * @param deviceId id of the device
     * @param zoneId id of the zone
     */
    clearSegments(deviceId: number, zoneId: number): void;
    /**
     * @private
     */
    sendMessage(commandId: number, buffer?: Buffer, deviceId?: number): void;
    /**
     * @private
     */
    readMessage(commandId: number, deviceId?: number): Promise<Buffer>;
    /**
     * @private
     */
    encodeHeader(commandId: number, length: number, deviceId: number): Buffer;
    /**
     * @private
     */
    decodeHeader(buffer: Buffer): {
        deviceId: number;
        commandId: number;
        length: number;
    };
    /**
     * @private
     */
    pack_color_list(arr: RGBColor[]): any;
    /**
     * @private
     */
    pack_string(string: string): Buffer;
}
export {};
//# sourceMappingURL=client.d.ts.map